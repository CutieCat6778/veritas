package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"fmt"
	"news-swipe/backend/graph/model"
	"news-swipe/backend/utils"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/landrade/gqlgen-cache-control-plugin/cache"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Articles returns all articles, optionally cached.
func (r *queryResolver) Articles(ctx context.Context) ([]*model.Article, error) {
	cache.SetHint(ctx, cache.ScopePublic, 15*time.Minute)

	lang := GetLanguageFromContext(ctx)

	var articles []*model.Article
	if err := r.DB.Preload("LinkedTo").Preload("LinkedFrom").Preload("Keywords").
		Where("language = ?", lang).
		Find(&articles).Error; err != nil {
		errStr, code := utils.HandleGormError(err)
		return nil, &gqlerror.Error{
			Path:    graphql.GetPath(ctx),
			Message: fmt.Sprintf("Failed to fetch articles: %s", errStr),
			Extensions: map[string]any{
				"code": code,
			},
		}
	}

	return articles, nil
}

// TopArticles returns articles ordered by views.
func (r *queryResolver) TopArticles(ctx context.Context, amount int32) ([]*model.Article, error) {
	cache.SetHint(ctx, cache.ScopePublic, 1*time.Minute)

	lang := GetLanguageFromContext(ctx)

	var articles []*model.Article
	if err := r.DB.Preload("LinkedTo").Preload("LinkedFrom").
		Where("language = ?", lang).
		Order("views DESC").
		Limit(int(amount)).
		Find(&articles).Error; err != nil {
		errStr, code := utils.HandleGormError(err)
		return nil, &gqlerror.Error{
			Path:    graphql.GetPath(ctx),
			Message: fmt.Sprintf("Failed to fetch top articles: %s", errStr),
			Extensions: map[string]any{
				"code": code,
			},
		}
	}

	r.UpdateViews(ctx, articles)
	return articles, nil
}

// LinkedArticles returns articles linked to a given article.
func (r *queryResolver) LinkedArticles(ctx context.Context, id string) ([]*model.Article, error) {
	cache.SetHint(ctx, cache.ScopePublic, 15*time.Minute)

	lang := GetLanguageFromContext(ctx)

	// Load the article with LinkedTo relation
	var article model.Article
	if err := r.DB.Preload("LinkedTo").First(&article, "id = ?", id).Error; err != nil {
		errStr, code := utils.HandleGormError(err)
		return nil, utils.GqlError("Failed to load article", errStr, code, ctx)
	}

	// If LinkedTo exists, filter by language and return
	if len(article.LinkedTo) > 0 {
		var filteredLinked []*model.Article
		for _, linked := range article.LinkedTo {
			if linked.Language == lang {
				filteredLinked = append(filteredLinked, linked)
			}
		}
		return filteredLinked, nil
	}

	// Otherwise, compute similarity (optional, your trigram query)
	tx := r.DB.Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
			panic(r)
		}
	}()

	if tx.Error != nil {
		return nil, utils.GqlError("Failed to start transaction", tx.Error.Error(), 500, ctx)
	}

	if err := tx.Exec("SET LOCAL pg_trgm.similarity_threshold = 0.29").Error; err != nil {
		tx.Rollback()
		errStr, code := utils.HandleGormError(err)
		return nil, utils.GqlError("Failed to set trigram threshold", errStr, code, ctx)
	}

	// Query similar articles (your existing raw SQL)
	query := `
		WITH source AS (
			SELECT * FROM articles WHERE id = ?
		)
		SELECT
			a2.*
		FROM
			source s
		JOIN
			articles a2 ON s.id < a2.id
		WHERE
			ABS(EXTRACT(EPOCH FROM (s.published_at - a2.published_at)) / 86400) <= 1
			AND a2.language = ?
		LIMIT 300;
	`

	var similar []*model.Article
	if err := tx.Raw(query, id, lang).Scan(&similar).Error; err != nil {
		tx.Rollback()
		errStr, code := utils.HandleGormError(err)
		return nil, utils.GqlError("Similarity query failed", errStr, code, ctx)
	}

	// Persist links via GORM association
	if len(similar) > 0 {
		if err := tx.Model(&article).Association("LinkedTo").Append(similar); err != nil {
			tx.Rollback()
			return nil, utils.GqlError("Failed to append LinkedTo", err.Error(), 500, ctx)
		}
	}

	if err := tx.Commit().Error; err != nil {
		return nil, utils.GqlError("Commit failed", err.Error(), 500, ctx)
	}

	return similar, nil
}

// Article returns a single article by ID.
func (r *queryResolver) Article(ctx context.Context, id string) (*model.Article, error) {
	lang := GetLanguageFromContext(ctx)

	var article model.Article
	if err := r.DB.Preload("LinkedTo").Preload("LinkedFrom").Preload("Keywords").
		Where("id = ? AND language = ?", id, lang).
		First(&article).Error; err != nil {
		errStr, code := utils.HandleGormError(err)
		return nil, &gqlerror.Error{
			Path:    graphql.GetPath(ctx),
			Message: fmt.Sprintf("Failed to fetch article with ID %s: %s", id, errStr),
			Extensions: map[string]any{
				"code": code,
			},
		}
	}

	r.UpdateViews(ctx, []*model.Article{&article})
	return &article, nil
}

// RecentArticle returns the most recently published articles.
func (r *queryResolver) RecentArticle(ctx context.Context, amount int32) ([]*model.Article, error) {
	cache.SetHint(ctx, cache.ScopePublic, 5*time.Minute)

	lang := GetLanguageFromContext(ctx)

	var articles []*model.Article
	if err := r.DB.Preload("LinkedTo").Preload("LinkedFrom").Preload("Keywords").
		Where("language = ?", lang).
		Order("published_at DESC").
		Limit(int(amount)).
		Find(&articles).Error; err != nil {
		errStr, code := utils.HandleGormError(err)
		graphql.AddError(ctx, &gqlerror.Error{
			Path:       graphql.GetPath(ctx),
			Message:    errStr,
			Extensions: map[string]any{"code": code},
		})
	}

	r.UpdateViews(ctx, articles)
	return articles, nil
}

// NextRecentArticle is the resolver for the nextRecentArticle field.
func (r *queryResolver) NextRecentArticle(ctx context.Context, start int32, stop int32) ([]*model.Article, error) {
	cache.SetHint(ctx, cache.ScopePublic, 5*time.Minute)

	lang := GetLanguageFromContext(ctx)

	limit := stop - start
	if limit <= 0 {
		return []*model.Article{}, nil
	}

	var articles []*model.Article
	if err := r.DB.Preload("LinkedTo").Preload("LinkedFrom").Preload("Keywords").
		Where("language = ?", lang).
		Order("published_at DESC").
		Offset(int(start)).
		Limit(int(limit)).
		Find(&articles).Error; err != nil {
		errStr, code := utils.HandleGormError(err)
		return nil, &gqlerror.Error{
			Path:       graphql.GetPath(ctx),
			Message:    fmt.Sprintf("Failed to fetch recent articles: %s", errStr),
			Extensions: map[string]any{"code": code},
		}
	}

	r.UpdateViews(ctx, articles)
	return articles, nil
}

// BatchFindArticles returns multiple articles by IDs.
func (r *queryResolver) BatchFindArticles(ctx context.Context, ids []*string) ([]*model.Article, error) {
	cache.SetHint(ctx, cache.ScopePublic, 24*7*time.Hour)

	lang := GetLanguageFromContext(ctx)

	nonNilIDs := make([]string, 0, len(ids))
	for _, id := range ids {
		if id != nil {
			nonNilIDs = append(nonNilIDs, *id)
		}
	}

	if len(nonNilIDs) == 0 {
		return []*model.Article{}, nil
	}

	var articles []*model.Article
	if err := r.DB.Preload("LinkedTo").Preload("LinkedFrom").Preload("Keywords").
		Where("id IN ? AND language = ?", nonNilIDs, lang).
		Find(&articles).Error; err != nil {
		errStr, code := utils.HandleGormError(err)
		return nil, &gqlerror.Error{
			Path:       graphql.GetPath(ctx),
			Message:    fmt.Sprintf("Failed to batch fetch articles: %s", errStr),
			Extensions: map[string]any{"code": code},
		}
	}

	r.UpdateViews(ctx, articles)
	return articles, nil
}

// Keywords returns all keywords with their linked articles.
func (r *queryResolver) Keywords(ctx context.Context) ([]*model.ResponseKeyWords, error) {
	lang := GetLanguageFromContext(ctx)

	var keywords []*model.KeyWords
	if err := r.DB.Preload("Articles", "language = ?", lang).Order("last_update DESC").Find(&keywords).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch keywords: %w", err)
	}

	var response []*model.ResponseKeyWords
	for _, kw := range keywords {
		if len(kw.Articles) == 0 {
			continue
		}
		response = append(response, &model.ResponseKeyWords{
			ID:         kw.ID,
			Keyword:    kw.Keyword,
			LastUpdate: kw.LastUpdate,
			Articles:   kw.Articles,
		})
	}

	return response, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
